"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populateDataTypeManager104 = exports.readDataTypeDefinitionAndBuildType = void 0;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_schemas_1 = require("node-opcua-schemas");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const convert_data_type_definition_to_structuretype_schema_1 = require("../convert_data_type_definition_to_structuretype_schema");
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
async function readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, name, dataTypeFactory, cache) {
    try {
        if (dataTypeFactory.getStructureInfoForDataType(dataTypeNodeId)) {
            return;
        }
        const [isAbstractDataValue, dataTypeDefinitionDataValue] = await session.read([
            {
                attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract,
                nodeId: dataTypeNodeId
            },
            {
                attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                nodeId: dataTypeNodeId
            }
        ]);
        /* istanbul ignore next */
        if (isAbstractDataValue.statusCode.isNotGood()) {
            throw new Error(" Cannot find dataType isAbstract ! with nodeId =" + dataTypeNodeId.toString());
        }
        const isAbstract = isAbstractDataValue.value.value;
        let dataTypeDefinition = dataTypeDefinitionDataValue.value.value;
        /* istanbul ignore next */
        if (dataTypeDefinitionDataValue.statusCode.isNotGood()) {
            // may be we are reading a 1.03 server
            if (!isAbstract) {
                warningLog(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
                return;
            }
            // it is OK to not have dataTypeDefinition for Abstract type!
            dataTypeDefinition = new node_opcua_types_1.StructureDefinition();
        }
        const schema = await (0, convert_data_type_definition_to_structuretype_schema_1.convertDataTypeDefinitionToStructureTypeSchema)(session, dataTypeNodeId, name, dataTypeDefinition, null, dataTypeFactory, isAbstract, cache);
        if (isAbstract) {
            // cannot construct an abstract structure
            dataTypeFactory.registerAbstractStructure(dataTypeNodeId, name, schema);
        }
        else {
            const Constructor = (0, node_opcua_schemas_1.createDynamicObjectConstructor)(schema, dataTypeFactory);
        }
    }
    catch (err) {
        errorLog("Error", err);
    }
}
exports.readDataTypeDefinitionAndBuildType = readDataTypeDefinitionAndBuildType;
class TaskMan {
    constructor() {
        this.taskList = [];
        this._runningTask = false;
        this._resolve = undefined;
    }
    async flushTaskList() {
        const firstTask = this.taskList.shift();
        this._runningTask = true;
        await firstTask();
        this._runningTask = false;
        if (this.taskList.length > 0) {
            setImmediate(async () => {
                await this.flushTaskList();
            });
        }
        else {
            if (this._resolve) {
                const tmpResolve = this._resolve;
                this._resolve = undefined;
                tmpResolve();
            }
        }
    }
    /**
     *
     * a little async task queue that gets executed sequentially
     * outside the main loop
     */
    registerTask(taskFunc) {
        this.taskList.push(taskFunc);
        if (this.taskList.length === 1 && !this._runningTask) {
            this.flushTaskList();
        }
    }
    async waitForCompletion() {
        if (this._resolve !== undefined) {
            throw new Error("already waiting");
        }
        await new Promise((resolve) => {
            this._resolve = resolve;
        });
    }
}
async function applyOnReferenceRecursively(session, nodeId, browseDescriptionTemplate, action) {
    const taskManager = new TaskMan();
    let pendingNodesToBrowse = [];
    function processBrowseResults(nodesToBrowse, browseResults) {
        for (let i = 0; i < browseResults.length; i++) {
            const result = browseResults[i];
            const nodeToBrowse = nodesToBrowse[i];
            if (result.statusCode.equals(node_opcua_status_code_1.StatusCodes.BadNoContinuationPoints) ||
                result.statusCode.equals(node_opcua_status_code_1.StatusCodes.BadContinuationPointInvalid)) {
                // not enough continuation points .. we need to rebrowse
                pendingNodesToBrowse.push(nodeToBrowse);
                //                taskManager.registerTask(flushBrowse);
            }
            else if (result.statusCode.isGood()) {
                for (const r of result.references || []) {
                    // also explore sub types
                    browseSubDataTypeRecursively(r.nodeId);
                    taskManager.registerTask(async () => await action(r));
                }
            }
            else {
                errorLog("Unexpected status code", i, new node_opcua_types_1.BrowseDescription(nodesToBrowse[i] || {})?.toString(), result.statusCode.toString());
            }
        }
    }
    async function flushBrowse() {
        if (pendingNodesToBrowse.length) {
            const nodesToBrowse = pendingNodesToBrowse;
            pendingNodesToBrowse = [];
            taskManager.registerTask(async () => {
                try {
                    const browseResults = await (0, node_opcua_pseudo_session_1.browseAll)(session, nodesToBrowse);
                    processBrowseResults(nodesToBrowse, browseResults);
                }
                catch (err) {
                    errorLog("err", err.message);
                    errorLog(nodesToBrowse.toString());
                }
            });
        }
    }
    function browseSubDataTypeRecursively(nodeId) {
        const nodeToBrowse = {
            ...browseDescriptionTemplate,
            nodeId
        };
        pendingNodesToBrowse.push(nodeToBrowse);
        taskManager.registerTask(async () => flushBrowse());
    }
    browseSubDataTypeRecursively(nodeId);
    await taskManager.waitForCompletion();
}
async function populateDataTypeManager104(session, dataTypeManager) {
    const cache = {};
    async function withDataType(r) {
        const dataTypeNodeId = r.nodeId;
        try {
            if (dataTypeNodeId.namespace === 0) {
                // already known I guess
                return;
            }
            let dataTypeFactory = dataTypeManager.getDataTypeFactory(dataTypeNodeId.namespace);
            if (!dataTypeFactory) {
                dataTypeFactory = new node_opcua_factory_1.DataTypeFactory([]);
                dataTypeManager.registerDataTypeFactory(dataTypeNodeId.namespace, dataTypeFactory);
                //   throw new Error("cannot find dataType Manager for namespace of " + dataTypeNodeId.toString());
            }
            // if not found already
            if (dataTypeFactory.getStructureInfoForDataType(dataTypeNodeId)) {
                // already known !
                return;
            }
            // extract it formally
            debugLog(" DataType => ", r.browseName.toString(), dataTypeNodeId.toString());
            await readDataTypeDefinitionAndBuildType(session, dataTypeNodeId, r.browseName.name, dataTypeFactory, cache);
        }
        catch (err) {
            errorLog("err=", err);
        }
    }
    const nodeToBrowse = {
        nodeId: node_opcua_nodeid_1.NodeId.nullNodeId,
        includeSubtypes: true,
        browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
        nodeClassMask: 0xff,
        referenceTypeId: (0, node_opcua_nodeid_1.resolveNodeId)("HasSubtype"),
        resultMask: 0xff
    };
    await applyOnReferenceRecursively(session, (0, node_opcua_nodeid_1.resolveNodeId)("Structure"), nodeToBrowse, withDataType);
}
exports.populateDataTypeManager104 = populateDataTypeManager104;
//# sourceMappingURL=populate_data_type_manager_104.js.map