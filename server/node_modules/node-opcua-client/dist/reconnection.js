"use strict";
/**
 * @module node-opcua-client-private
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.repair_client_sessions = exports.repair_client_session = void 0;
// tslint:disable:only-arrow-functions
const async = __importStar(require("async"));
const chalk_1 = __importDefault(require("chalk"));
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_service_subscription_1 = require("node-opcua-service-subscription");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_client_dynamic_extension_object_1 = require("node-opcua-client-dynamic-extension-object");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("RECONNECTION");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("RECONNECTION");
const errorLog = (0, node_opcua_debug_1.make_errorLog)("RECONNECTION");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("RECONNECTION");
//
// a new secure channel has be created, we need to reactivate the corresponding session,
// and reestablish the subscription and restart the publish engine.
//
//
// see OPC UA part 4 ( version 1.03 ) figure 34 page 106
// 6.5 Reestablishing subscription....
//
//
//
//                      +---------------------+
//                      | CreateSecureChannel |
//                      | CreateSession       |
//                      | ActivateSession     |
//                      +---------------------+
//                                |
//                                |
//                                v
//                      +---------------------+
//                      | CreateSubscription  |<-------------------------------------------------------------+
//                      +---------------------+                                                              |
//                                |                                                                         (1)
//                                |
//                                v
//                      +---------------------+
//     (2)------------->| StartPublishEngine  |
//                      +---------------------+
//                                |
//                                V
//                      +---------------------+
//             +------->| Monitor Connection  |
//             |        +---------------------+
//             |                    |
//             |                    v
//             |          Good    /   \
//             +-----------------/ SR? \______Broken_____+
//                               \     /                 |
//                                \   /                  |
//                                                       |
//                                                       v
//                                                 +---------------------+
//                                                 |                     |
//                                                 | CreateSecureChannel |<-----+
//                                                 |                     |      |
//                                                 +---------------------+      |
//                                                         |                    |
//                                                         v                    |
//                                                       /   \                  |
//                                                      / SR? \______Bad________+
//                                                      \     /
//                                                       \   /
//                                                         |
//                                                         |Good
//                                                         v
//                                                 +---------------------+
//                                                 |                     |
//                                                 | ActivateSession     |
//                                                 |                     |
//                                                 +---------------------+
//                                                         |
//                                  +----------------------+
//                                  |
//                                  v                    +-------------------+       +----------------------+
//                                /   \                  | CreateSession     |       |                      |
//                               / SR? \______Bad_______>| ActivateSession   |-----> | TransferSubscription |
//                               \     /                 |                   |       |                      |       (1)
//                                \   /                  +-------------------+       +----------------------+        ^
//                                  | Good                                                      |                    |
//                                  v   (for each subscription)                                 |                    |
//                          +--------------------+                                            /   \                  |
//                          |                    |                                     OK    / OK? \______Bad________+
//                          | RePublish          |<----------------------------------------- \     /
//                      +-->|                    |                                            \   /
//                      |   +--------------------+
//                      |           |
//                      |           v
//                      | GOOD    /   \
//                      +------  / SR? \______Bad SubscriptionInvalidId______>(1)
// (2)                           \     /
//  ^                             \   /
//  |                               |
//  |                               |
//  |      BadMessageNotAvailable   |
//  +-------------------------------+
function _ask_for_subscription_republish(session, callback) {
    if (session.hasBeenClosed()) {
        doDebug && debugLog("_ask_for_subscription_republish :  session is closed");
        return callback(new Error("askForSubscriptionRepublish => canceled because session is closed"));
    }
    doDebug && debugLog(chalk_1.default.bgCyan.yellow.bold("_ask_for_subscription_republish "));
    // assert(session.getPublishEngine().nbPendingPublishRequests === 0,
    //   "at this time, publish request queue shall still be empty");
    session.getPublishEngine().republish((err) => {
        doDebug && debugLog("_ask_for_subscription_republish :  republish sent");
        if (session.hasBeenClosed()) {
            return callback(new Error("Cannot complete subscription republish due to session termination"));
        }
        doDebug && debugLog(chalk_1.default.bgCyan.green.bold("_ask_for_subscription_republish done "), err ? err.message : "OK");
        if (err) {
            warningLog("republish has failed with error :", err.message);
            doDebug && debugLog("_ask_for_subscription_republish has :  recreating subscription");
            return repair_client_session_by_recreating_a_new_session(session._client, session, callback);
        }
        // xx assert(session.getPublishEngine().nbPendingPublishRequests === 0);
        session.resumePublishEngine();
        callback(err);
    });
}
function create_session_and_repeat_if_failed(client, session, callback) {
    if (session.hasBeenClosed()) {
        doDebug && debugLog("Cannot complete subscription republish due to session termination");
        return callback(new Error("Cannot complete subscription republish due to session termination"));
    }
    doDebug && debugLog(chalk_1.default.bgWhite.red("    => creating a new session ...."));
    // create new session, based on old session,
    // so we can reuse subscriptions data
    client.__createSession_step2(session, (err, session1) => {
        if (err && session.hasBeenClosed()) {
            doDebug && debugLog("Cannot complete subscription republish due to session termination");
            return callback(new Error("Cannot complete subscription republish due to session termination"));
        }
        if (!err && session1) {
            (0, node_opcua_assert_1.assert)(session === session1, "session should have been recycled");
            callback(err, session);
            return;
        }
        else {
            doDebug && debugLog("Cannot complete subscription republish err = ", err?.message);
            callback(err);
        }
    });
}
function repair_client_session_by_recreating_a_new_session(client, session, callback) {
    if (session._client && session._client.isUnusable()) {
        return callback(new Error("Client is unusable"));
    }
    // As we don"t know if server has been rebooted or not,
    // and may be upgraded in between, we have to invalidate the extra data type manager
    (0, node_opcua_client_dynamic_extension_object_1.invalidateExtraDataTypeManager)(session);
    // istanbul ignore next
    if (doDebug) {
        debugLog(" repairing client session by_recreating a new session for old session ", session.sessionId.toString());
    }
    //  TO DO : it is possible that session is already closed while we get there
    if (session.hasBeenClosed()) {
        // istanbul ignore next
        doDebug && debugLog(chalk_1.default.bgWhite.red("Aborting reactivation of old session because user requested session to be closed"));
        return callback(new Error("reconnection cancelled due to session termination"));
    }
    let newSession;
    const listenerCountBefore = session.listenerCount("");
    function recreateSubscription(subscriptionsToRecreate, innerCallback) {
        async.forEach(subscriptionsToRecreate, (subscriptionId, next) => {
            if (!session.getPublishEngine().hasSubscription(subscriptionId)) {
                doDebug && debugLog(chalk_1.default.red("          => CANNOT RECREATE SUBSCRIPTION  "), subscriptionId);
                return next();
            }
            const subscription = session.getPublishEngine().getSubscription(subscriptionId);
            (0, node_opcua_assert_1.assert)(subscription.constructor.name === "ClientSubscriptionImpl");
            doDebug && debugLog(chalk_1.default.red("          => RECREATING SUBSCRIPTION  "), subscriptionId);
            (0, node_opcua_assert_1.assert)(subscription.session === newSession, "must have the session");
            subscription.recreateSubscriptionAndMonitoredItem((err1) => {
                if (err1) {
                    doDebug && debugLog("_recreateSubscription failed !" + err1.message);
                }
                doDebug &&
                    debugLog(chalk_1.default.cyan("          => RECREATING SUBSCRIPTION  AND MONITORED ITEM DONE "), subscriptionId);
                next();
            });
        }, (err1) => {
            innerCallback(err1);
        });
    }
    async.series([
        function suspend_old_session_publish_engine(innerCallback) {
            if (session.hasBeenClosed()) {
                return innerCallback(new Error("Cannot complete subscription republish due to session termination"));
            }
            // istanbul ignore next
            doDebug && debugLog(chalk_1.default.bgWhite.red("    => suspend old session publish engine...."));
            session.getPublishEngine().suspend(true);
            innerCallback();
        },
        function create_new_session(innerCallback) {
            create_session_and_repeat_if_failed(client, session, (err, _newSession) => {
                if (_newSession) {
                    newSession = _newSession;
                }
                innerCallback(err || undefined);
            });
        },
        function activate_new_session(innerCallback) {
            if (session.hasBeenClosed()) {
                return innerCallback(new Error("Cannot complete subscription republish due to session termination"));
            }
            doDebug && debugLog(chalk_1.default.bgWhite.red("    => activating a new session ...."));
            client._activateSession(newSession, newSession.userIdentityInfo, (err, session1) => {
                // istanbul ignore next
                doDebug && debugLog("    =>  activating a new session .... Done err=", err ? err.message : "null");
                if (err) {
                    doDebug &&
                        debugLog("reactivation of the new session has failed: let be smart and close it before failing this repair attempt");
                    // but just on the server side, not on the client side
                    const closeSessionRequest = new node_opcua_types_1.CloseSessionRequest({
                        requestHeader: {
                            authenticationToken: newSession.authenticationToken
                        },
                        deleteSubscriptions: true
                    });
                    newSession._client.performMessageTransaction(closeSessionRequest, (err2) => {
                        if (err2) {
                            warningLog("closing session", err2.message);
                        }
                        // istanbul ignore next
                        doDebug && debugLog("the temporary replacement session is now closed");
                        // istanbul ignore next
                        doDebug && debugLog(" err ", err.message, "propagated upwards");
                        innerCallback(err);
                    });
                }
                else {
                    innerCallback(err ? err : undefined);
                }
            });
        },
        function attempt_subscription_transfer(innerCallback) {
            if (session.hasBeenClosed()) {
                return innerCallback(new Error("Cannot complete subscription republish due to session termination"));
            }
            // get the old subscriptions id from the old session
            const subscriptionsIds = session.getPublishEngine().getSubscriptionIds();
            doDebug && debugLog("  session subscriptionCount = ", newSession.getPublishEngine().subscriptionCount);
            if (subscriptionsIds.length === 0) {
                doDebug && debugLog(" No subscriptions => skipping transfer subscriptions");
                return innerCallback(); // no need to transfer subscriptions
            }
            doDebug && debugLog("    => asking server to transfer subscriptions = [", subscriptionsIds.join(", "), "]");
            // Transfer subscriptions - ask for initial values....
            const subscriptionsToTransfer = new node_opcua_service_subscription_1.TransferSubscriptionsRequest({
                sendInitialValues: true,
                subscriptionIds: subscriptionsIds
            });
            if (newSession.getPublishEngine().nbPendingPublishRequests !== 0) {
                warningLog("Warning : we should not be publishing here");
            }
            newSession.transferSubscriptions(subscriptionsToTransfer, (err, transferSubscriptionsResponse) => {
                if (err || !transferSubscriptionsResponse) {
                    warningLog(chalk_1.default.bgCyan("Warning TransferSubscription has failed " + err?.message));
                    warningLog(chalk_1.default.bgCyan("May be the server is not supporting this feature"));
                    // when transfer subscription has failed, we have no other choice but
                    // recreate the subscriptions on the server side
                    const subscriptionsToRecreate = [...(subscriptionsToTransfer.subscriptionIds || [])];
                    warningLog(chalk_1.default.bgCyan("We need to recreate entirely the subscription"));
                    recreateSubscription(subscriptionsToRecreate, innerCallback);
                    return;
                }
                const results = transferSubscriptionsResponse.results || [];
                // istanbul ignore next
                if (doDebug) {
                    debugLog(chalk_1.default.cyan("    =>  transfer subscriptions  done"), results.map((x) => x.statusCode.toString()).join(" "));
                }
                const subscriptionsToRecreate = [];
                // some subscriptions may be marked as invalid on the server side ...
                // those one need to be recreated and repaired ....
                for (let i = 0; i < results.length; i++) {
                    const statusCode = results[i].statusCode;
                    if (statusCode.equals(node_opcua_status_code_1.StatusCodes.BadSubscriptionIdInvalid)) {
                        // repair subscription
                        doDebug &&
                            debugLog(chalk_1.default.red("         WARNING SUBSCRIPTION  "), subscriptionsIds[i], chalk_1.default.red(" SHOULD BE RECREATED"));
                        subscriptionsToRecreate.push(subscriptionsIds[i]);
                    }
                    else {
                        const availableSequenceNumbers = results[i].availableSequenceNumbers;
                        doDebug &&
                            debugLog(chalk_1.default.green("         SUBSCRIPTION "), subscriptionsIds[i], chalk_1.default.green(" CAN BE REPAIRED AND AVAILABLE "), availableSequenceNumbers);
                        // should be Good.
                    }
                }
                doDebug && debugLog("  new session subscriptionCount = ", newSession.getPublishEngine().subscriptionCount);
                recreateSubscription(subscriptionsToRecreate, innerCallback);
            });
        },
        function ask_for_subscription_republish(innerCallback) {
            if (session.hasBeenClosed()) {
                return innerCallback(new Error("Cannot complete subscription republish due to session termination"));
            }
            //  assert(newSession.getPublishEngine().nbPendingPublishRequests === 0, "we should not be publishing here");
            //      call Republish
            return _ask_for_subscription_republish(newSession, (err) => {
                if (err) {
                    warningLog("warning: Subscription republished has failed ", err.message);
                }
                innerCallback(err);
            });
        },
        function start_publishing_as_normal(innerCallback) {
            if (session.hasBeenClosed()) {
                return innerCallback(new Error("Cannot complete subscription republish due to session termination"));
            }
            newSession.getPublishEngine().suspend(false);
            const listenerCountAfter = session.listenerCount("");
            (0, node_opcua_assert_1.assert)(newSession === session);
            doDebug && debugLog("listenerCountBefore =", listenerCountBefore, "listenerCountAfter = ", listenerCountAfter);
            innerCallback();
        }
    ], (err) => {
        doDebug && err && debugLog("repair_client_session_by_recreating_a_new_session failed with ", err.message);
        callback(err);
    });
}
function _repair_client_session(client, session, callback) {
    const callback2 = (err2) => {
        doDebug &&
            debugLog("Session repair completed with err: ", err2 ? err2.message : "<no error>", session.sessionId.toString());
        if (!err2) {
            session.emit("session_repaired");
        }
        callback(err2);
    };
    if (doDebug) {
        doDebug && debugLog(chalk_1.default.yellow("  TRYING TO REACTIVATE EXISTING SESSION"), session.sessionId.toString());
        doDebug && debugLog("   SubscriptionIds :", session.getPublishEngine().getSubscriptionIds());
    }
    client._activateSession(session, session.userIdentityInfo, (err, session2) => {
        //
        // Note: current limitation :
        //  - The reconnection doesn't work yet, if connection break is caused by a server that crashes and restarts.
        //
        doDebug && debugLog("   ActivateSession : ", err ? chalk_1.default.red(err.message) : chalk_1.default.green(" SUCCESS !!! "));
        if (err) {
            //  activate old session has failed => let's  recreate a new Channel and transfer the subscription
            return repair_client_session_by_recreating_a_new_session(client, session, callback2);
        }
        else {
            // activate old session has succeeded => let's call Republish
            return _ask_for_subscription_republish(session, callback2);
        }
    });
}
function repair_client_session(client, session, callback) {
    if (!client) {
        doDebug && debugLog("Aborting reactivation of old session because user requested session to be close");
        return callback();
    }
    doDebug && debugLog(chalk_1.default.yellow("Starting client session repair"));
    const privateSession = session;
    privateSession._reconnecting = privateSession._reconnecting || { reconnecting: false, pendingCallbacks: [] };
    if (privateSession._reconnecting.reconnecting) {
        doDebug && debugLog(chalk_1.default.bgCyan("Reconnecting already happening for session"), session.sessionId.toString());
        privateSession._reconnecting.pendingCallbacks.push(callback);
        return;
    }
    privateSession._reconnecting.reconnecting = true;
    // get old transaction queue ...
    const transactionQueue = privateSession.pendingTransactions ? privateSession.pendingTransactions.splice(0) : [];
    const repeatedAction = (callback) => {
        _repair_client_session(client, session, (err) => {
            if (err) {
                errorLog(chalk_1.default.red("session restoration has failed! err ="), err.message, session.sessionId.toString(), " => Let's retry");
                if (!session.hasBeenClosed()) {
                    const delay = 2000;
                    errorLog(chalk_1.default.red(`... will retry session repair... in ${delay} ms`));
                    setTimeout(() => {
                        errorLog(chalk_1.default.red("Retrying session repair..."));
                        repeatedAction(callback);
                    }, delay);
                    return;
                }
                else {
                    errorLog(chalk_1.default.red("session restoration should be interrupted because session has been closed forcefully"));
                    // session does not need to be repaired anymore
                    callback();
                }
                return;
            }
            privateSession._reconnecting.reconnecting = false;
            // istanbul ignore next
            doDebug && debugLog(chalk_1.default.yellow("session has been restored"), session.sessionId.toString());
            session.emit("session_restored");
            const otherCallbacks = privateSession._reconnecting.pendingCallbacks;
            privateSession._reconnecting.pendingCallbacks = [];
            // re-inject element in queue
            // istanbul ignore next
            doDebug && debugLog(chalk_1.default.yellow("re-injecting transaction queue"), transactionQueue.length);
            transactionQueue.forEach((e) => privateSession.pendingTransactions.push(e));
            otherCallbacks.forEach((c) => c(err));
            callback(err);
        });
    };
    repeatedAction(callback);
}
exports.repair_client_session = repair_client_session;
function repair_client_sessions(client, callback) {
    // repair session
    const sessions = client.getSessions();
    doDebug && debugLog(chalk_1.default.red.bgWhite(" Starting sessions reactivation", sessions.length));
    async.map(sessions, (session, next) => {
        repair_client_session(client, session, (err) => {
            next(null, err);
        });
    }, (err, allErrors) => {
        err && errorLog("sessions reactivation completed with err: err ", err ? err.message : "null");
        return callback(err);
    });
}
exports.repair_client_sessions = repair_client_sessions;
//# sourceMappingURL=reconnection.js.map