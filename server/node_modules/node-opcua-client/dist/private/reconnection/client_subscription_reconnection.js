"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.recreateSubscriptionAndMonitoredItem = void 0;
const async_1 = __importDefault(require("async"));
const node_opcua_assert_1 = __importDefault(require("node-opcua-assert"));
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_pki_1 = require("node-opcua-pki");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const client_subscription_impl_1 = require("../client_subscription_impl");
const reconnection_1 = require("./reconnection");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("RECONNECTION");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("RECONNECTION");
function createMonitoredItemsAndRespectOperationalLimits(session, createMonitorItemsRequest, callback) {
    (0, node_opcua_pseudo_session_1.readOperationLimits)(session)
        .then((operationalLimits) => {
        (0, node_opcua_pseudo_session_1.createMonitoredItemsLimit)(operationalLimits.maxMonitoredItemsPerCall || 0, session, createMonitorItemsRequest)
            .then((createMonitoredItemResponse) => callback(null, createMonitoredItemResponse))
            .catch(callback);
    })
        .catch(callback);
}
/**
 *  utility function to recreate new subscription
 *  @method recreateSubscriptionAndMonitoredItem
 */
function recreateSubscriptionAndMonitoredItem(_subscription, callback) {
    debugLog("recreateSubscriptionAndMonitoredItem", _subscription.subscriptionId.toString());
    const subscription = _subscription;
    if (subscription.subscriptionId === client_subscription_impl_1.TERMINATED_SUBSCRIPTION_ID) {
        debugLog("Subscription is not in a valid state");
        return callback();
    }
    const oldMonitoredItems = subscription.monitoredItems;
    const oldSubscriptionId = subscription.subscriptionId;
    subscription.publishEngine.unregisterSubscription(oldSubscriptionId);
    async_1.default.series([
        (innerCallback) => {
            (0, client_subscription_impl_1.__create_subscription)(subscription, innerCallback);
        },
        (innerCallback) => {
            // prettier-ignore
            {
                const _err = (0, reconnection_1._shouldNotContinue)(subscription.session);
                if (_err) {
                    return innerCallback(_err);
                }
            }
            const test = subscription.publishEngine.getSubscription(subscription.subscriptionId);
            debugLog("recreating ", Object.keys(oldMonitoredItems).length, " monitored Items");
            // re-create monitored items
            const itemsToCreate = [];
            for (const monitoredItem of Object.values(oldMonitoredItems)) {
                (0, node_opcua_assert_1.default)(monitoredItem.monitoringParameters.clientHandle > 0);
                itemsToCreate.push({
                    itemToMonitor: monitoredItem.itemToMonitor,
                    monitoringMode: monitoredItem.monitoringMode,
                    requestedParameters: monitoredItem.monitoringParameters
                });
            }
            const createMonitorItemsRequest = new node_opcua_types_1.CreateMonitoredItemsRequest({
                itemsToCreate,
                subscriptionId: subscription.subscriptionId,
                timestampsToReturn: node_opcua_data_value_1.TimestampsToReturn.Both // this.timestampsToReturn,
            });
            const session = subscription.session;
            // istanbul ignore next
            if (!session) {
                return innerCallback(new Error("no session"));
            }
            debugLog("Recreating ", itemsToCreate.length, " monitored items");
            createMonitoredItemsAndRespectOperationalLimits(session, createMonitorItemsRequest, (err, response) => {
                if (err) {
                    debugLog("Recreating monitored item has failed with ", err.message);
                    return innerCallback(err);
                }
                /* istanbul ignore next */
                if (!response) {
                    return innerCallback(new Error("Internal Error"));
                }
                const monitoredItemResults = response.results || [];
                let _errCount = 0;
                monitoredItemResults.forEach((monitoredItemResult, index) => {
                    const itemToCreate = itemsToCreate[index];
                    /* istanbul ignore next */
                    if (!itemToCreate || !itemToCreate.requestedParameters) {
                        _errCount++;
                        return;
                    }
                    const clientHandle = itemToCreate.requestedParameters.clientHandle;
                    /* istanbul ignore next */
                    if (!clientHandle) {
                        _errCount++;
                        return;
                    }
                    const monitoredItem = subscription.monitoredItems[clientHandle];
                    if (monitoredItem) {
                        monitoredItem._applyResult(monitoredItemResult);
                    }
                    else {
                        _errCount++;
                        (0, node_opcua_pki_1.warningLog)("cannot find monitored item for clientHandle !:", clientHandle);
                        (0, node_opcua_pki_1.warningLog)("itemsToCreate = ", itemsToCreate[index].toString());
                    }
                });
                if (_errCount > 0) {
                    (0, node_opcua_pki_1.warningLog)("Warning: some monitored items have not been recreated properly");
                }
                innerCallback();
            });
        }
    ], (err) => {
        if (err) {
            (0, node_opcua_pki_1.warningLog)("!!recreateSubscriptionAndMonitoredItem has failed", err.message);
        }
        callback(err);
    });
}
exports.recreateSubscriptionAndMonitoredItem = recreateSubscriptionAndMonitoredItem;
//# sourceMappingURL=client_subscription_reconnection.js.map